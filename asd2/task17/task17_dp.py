'''
# Задача о раскладке по ящикам может быть решена с помощью динамического программирования.
# Предположим, что у нас есть n предметов и m ящиков. Мы хотим распределить все предметы по ящикам так, чтобы минимизировать общий вес ящиков.

# Введем функцию dp[i][j], которая будет хранить минимальный общий вес ящиков, если мы распределим первые i предметов по j ящикам.

# Начальное условие: dp[0][j] = 0 для всех j, потому что если у нас нет предметов, то общий вес ящиков равен нулю.

# Переходные условия: dp[i][j] = min(dp[i-1][j-1] + w[i], dp[i-1][j]), где w[i] - вес i-го предмета.

# Ответом будет dp[n][m].

# Пример кода:

def min_weight(n, m, w):
    # Инициализация dp
    dp = [[float('inf')] * (m + 1) for _ in range(n + 1)]
    dp[0][0] = 0

    # Переход по состояниям
    for i in range(1, n + 1):
        for j in range(1, m + 1):
            dp[i][j] = min(dp[i-1][j-1] + w[i-1], dp[i-1][j])

    # Возвращаем ответ
    return dp[n][m]

# Тестирование функции на примере
n = 5  # количество предметов
m = 3  # количество ящиков
w = [1, 2, 3, 4, 5]  # веса предметов

print(min_weight(n, m, w))  # вывод: 6
'''

# Задача о раскладке по ящикам может быть решена с помощью алгоритма Best Fit.
# Предположим, что у нас есть n предметов и m ящиков. Мы хотим распределить все предметы по ящикам так, чтобы минимизировать общий вес ящиков.

# Введем функцию best_fit, которая будет решать эту задачу.

# Пример кода:

def best_fit(weights, n, c):  # Определение функции best_fit с тремя аргументами: weights (веса предметов), n (количество предметов) и c (вместимость ящика)
    res = 0  # Инициализация переменной res, которая будет хранить количество используемых ящиков

    bin_rem = [0]*n  # Создание массива bin_rem размером n, который будет хранить оставшееся пространство в каждом ящике

    for i in range(n):  # Цикл по всем предметам
        min = c + 1  # Инициализация переменной min, которая будет хранить минимальное оставшееся пространство в ящике
        bi = 0  # Инициализация переменной bi, которая будет хранить индекс ящика с минимальным оставшимся пространством

        for j in range(res):  # Цикл по всем используемым ящикам
            if (bin_rem[j] >= weights[i] and bin_rem[j] - weights[i] < min):  # Если текущий ящик может вместить текущий предмет и оставшееся пространство в ящике меньше min
                bi = j  # Обновление bi
                min = bin_rem[j] - weights[i]  # Обновление min

        if (min == c + 1):  # Если ни один ящик не может вместить текущий предмет
            bin_rem[res] = c - weights[i]  # Создаем новый ящик и помещаем в него текущий предмет
            res += 1  # Увеличиваем количество используемых ящиков
        else:  # Если найден ящик, который может вместить текущий предмет
            bin_rem[bi] -= weights[i]  # Помещаем предмет в ящик и обновляем оставшееся пространство в ящике

    return res  # Возвращаем количество используемых ящиков

weights = [2, 1, 8, 7, 6, 5]  # Веса предметов
n = len(weights)  # Количество предметов
c = 10  # Вместимость ящика

print(best_fit(weights, n, c))  # Выводим количество используемых ящиков для данного набора предметов и ящика определенной вместимости